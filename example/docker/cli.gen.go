// AUTOGENERATED -- DO NOT EDIT
package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"strings"
)

// Application defines the entrypoints to the application logic.
type Application interface {
	DockerContainerLs
	DockerContainerRm
	DockerContainerStart
	DockerNetworkInspect
	DockerVolumeLs
	DockerVolumeRm
}

type command struct {
	w          io.Writer
	help       string
	helpBuffer *bytes.Buffer
	flags      *flag.FlagSet
}

func newCommand(name string, help string, w io.Writer) command {
	flags := flag.NewFlagSet(name, flag.ContinueOnError)
	helpBuffer := new(bytes.Buffer)
	flags.SetOutput(helpBuffer)

	return command{
		w:          w,
		help:       help,
		helpBuffer: helpBuffer,
		flags:      flags,
	}
}

// appendFlagUsage returns a function that appends a string describing the flags
// usage to the slice passed in. The usage is of the form
// `[-<flag name> <flag type>]`. For boolean flags the <flag type> is omitted.
func appendFlagUsage(usage []string) func(f *flag.Flag) {
	return func(f *flag.Flag) {
		flagArg := ""
		if typ, _ := flag.UnquoteUsage(f); typ != "" {
			flagArg = fmt.Sprintf(" <%s>", typ)
		}
		usage = append(usage, fmt.Sprintf("[-%s%s]", f.Name, flagArg))
	}
}

type dockerCommand struct {
	command
	container dockerContainerCommand
	network   dockerNetworkCommand
	volume    dockerVolumeCommand
}

func newDockerCommand(w io.Writer, app Application) dockerCommand {
	command := newCommand("docker", "Docker is an example of an app that has many nested subcommands.", w)
	c := dockerCommand{
		command:   command,
		container: newDockerContainerCommand(w, app),
		network:   newDockerNetworkCommand(w, app),
		volume:    newDockerVolumeCommand(w, app),
	}
	c.flags.Usage = c.bufferHelp

	return c
}

func (c *dockerCommand) usage() string {
	usage := []string{"Usage:", "docker"}
	usage = append(usage, "<command>")
	c.flags.VisitAll(appendFlagUsage(usage))

	return strings.Join(usage, " ")
}

func (c *dockerCommand) bufferHelp() {
	fmt.Fprintf(c.helpBuffer, "%s\n\n", c.help)
	fmt.Fprintf(c.helpBuffer, "%s\n", c.usage())
	fmt.Fprintln(c.helpBuffer, "\nCommands:")
	fmt.Fprintln(c.helpBuffer, "  container: Manage containers")
	fmt.Fprintln(c.helpBuffer, "  network: Manage networks")
	fmt.Fprintln(c.helpBuffer, "  volume: Manage volumes")

}

func (c *dockerCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *dockerCommand) run(args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("sub-command required")
	}
	switch args[0] {
	case "container":
		return c.container.run(args[1:])
	case "network":
		return c.network.run(args[1:])
	case "volume":
		return c.volume.run(args[1:])
	default:
		err := c.flags.Parse(args)
		if err == flag.ErrHelp {
			return c.writeHelp()
		}
		if err != nil {
			return err
		}
		return fmt.Errorf("Unknown command: %q", args[0])
	}
}

type dockerContainerCommand struct {
	command
	ls    dockerContainerLsCommand
	rm    dockerContainerRmCommand
	start dockerContainerStartCommand
}

func newDockerContainerCommand(w io.Writer, app Application) dockerContainerCommand {
	command := newCommand("container", "Manage containers", w)
	c := dockerContainerCommand{
		command: command,
		ls:      newDockerContainerLsCommand(w, app),
		rm:      newDockerContainerRmCommand(w, app),
		start:   newDockerContainerStartCommand(w, app),
	}
	c.flags.Usage = c.bufferHelp

	return c
}

func (c *dockerContainerCommand) usage() string {
	usage := []string{"Usage:", "docker", "container"}
	usage = append(usage, "<command>")
	c.flags.VisitAll(appendFlagUsage(usage))

	return strings.Join(usage, " ")
}

func (c *dockerContainerCommand) bufferHelp() {
	fmt.Fprintf(c.helpBuffer, "%s\n\n", c.help)
	fmt.Fprintf(c.helpBuffer, "%s\n", c.usage())
	fmt.Fprintln(c.helpBuffer, "\nCommands:")
	fmt.Fprintln(c.helpBuffer, "  ls: List containers")
	fmt.Fprintln(c.helpBuffer, "  rm: Remove one or more containers")
	fmt.Fprintln(c.helpBuffer, "  start: Start one or more stopped containers")

}

func (c *dockerContainerCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *dockerContainerCommand) run(args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("sub-command required")
	}
	switch args[0] {
	case "ls":
		return c.ls.run(args[1:])
	case "rm":
		return c.rm.run(args[1:])
	case "start":
		return c.start.run(args[1:])
	default:
		err := c.flags.Parse(args)
		if err == flag.ErrHelp {
			return c.writeHelp()
		}
		if err != nil {
			return err
		}
		return fmt.Errorf("Unknown command: %q", args[0])
	}
}

type DockerContainerLs interface {
	RunDockerContainerLs(all bool, filter string, format string, last int, noTrunc bool, quiet bool, size bool) error
}

type dockerContainerLsCommand struct {
	command
	all     *bool
	filter  *string
	format  *string
	last    *int
	noTrunc *bool
	quiet   *bool
	size    *bool
	ls      DockerContainerLs
}

func newDockerContainerLsCommand(w io.Writer, ls DockerContainerLs) dockerContainerLsCommand {
	command := newCommand("ls", "List containers", w)
	c := dockerContainerLsCommand{
		command: command,
		all:     command.flags.Bool("all", false, "Show all containers (default shows just running containers)"),
		filter:  command.flags.String("filter", "", "Filter output based on conditions provided"),
		format:  command.flags.String("format", "", "Pretty-print container using a Go template"),
		last:    command.flags.Int("last", -1, "Show n last created containers (incluides all states)"),
		noTrunc: command.flags.Bool("no-trunc", false, "Don't truncate output"),
		quiet:   command.flags.Bool("quiet", false, "Only display containers IDs"),
		size:    command.flags.Bool("size", false, "Display total file sizes"),
		ls:      ls,
	}
	c.flags.Usage = c.bufferHelp

	return c
}

func (c *dockerContainerLsCommand) usage() string {
	usage := []string{"Usage:", "docker", "container", "ls"}
	c.flags.VisitAll(appendFlagUsage(usage))

	return strings.Join(usage, " ")
}

func (c *dockerContainerLsCommand) bufferHelp() {
	fmt.Fprintf(c.helpBuffer, "%s\n\n", c.help)
	fmt.Fprintf(c.helpBuffer, "%s\n", c.usage())

	fmt.Fprintf(c.helpBuffer, "\nFlags:\n")
	c.flags.PrintDefaults()
}

func (c *dockerContainerLsCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *dockerContainerLsCommand) run(args []string) error {
	switch err := c.flags.Parse(args); err {
	case nil:

		args = c.flags.Args()
		if len(args) < 0 {
			return fmt.Errorf("'docker container ls': too few arguments; expect 0, but got %d", len(args))
		}
		if len(args) > 0 {
			return fmt.Errorf("'docker container ls': too many arguments; expect 0, but got %d", len(args))
		}
		return c.ls.RunDockerContainerLs(*c.all, *c.filter, *c.format, *c.last, *c.noTrunc, *c.quiet, *c.size)
	case flag.ErrHelp:
		return c.writeHelp()
	default:
		return err
	}
}

type DockerContainerRm interface {
	RunDockerContainerRm(force bool, link bool, volumes bool, container string, containers ...string) error
}

type dockerContainerRmCommand struct {
	command
	force   *bool
	link    *bool
	volumes *bool
	rm      DockerContainerRm
}

func newDockerContainerRmCommand(w io.Writer, rm DockerContainerRm) dockerContainerRmCommand {
	command := newCommand("rm", "Remove one or more containers", w)
	c := dockerContainerRmCommand{
		command: command,
		force:   command.flags.Bool("force", false, "Force the removal of a running container (uses SIGKILL)"),
		link:    command.flags.Bool("link", false, "Remove the specified link"),
		volumes: command.flags.Bool("volumes", false, "Remove anonymous volumes associated with the container"),
		rm:      rm,
	}
	c.flags.Usage = c.bufferHelp

	return c
}

func (c *dockerContainerRmCommand) usage() string {
	usage := []string{"Usage:", "docker", "container", "rm"}
	c.flags.VisitAll(appendFlagUsage(usage))
	usage = append(usage, "<container>")
	usage = append(usage, "[<containers>...]")
	return strings.Join(usage, " ")
}

func (c *dockerContainerRmCommand) bufferHelp() {
	fmt.Fprintf(c.helpBuffer, "%s\n\n", c.help)
	fmt.Fprintf(c.helpBuffer, "%s\n", c.usage())

	fmt.Fprintf(c.helpBuffer, "\nArguments:\n")
	fmt.Fprintln(c.helpBuffer, "  container: The container to remove")
	fmt.Fprintf(c.helpBuffer, "\nFlags:\n")
	c.flags.PrintDefaults()
}

func (c *dockerContainerRmCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *dockerContainerRmCommand) run(args []string) error {
	switch err := c.flags.Parse(args); err {
	case nil:

		args = c.flags.Args()
		if len(args) < 1 {
			return fmt.Errorf("'docker container rm': too few arguments; expect 1 or more, but got %d", len(args))
		}

		return c.rm.RunDockerContainerRm(*c.force, *c.link, *c.volumes, args[0], args[1:]...)
	case flag.ErrHelp:
		return c.writeHelp()
	default:
		return err
	}
}

type DockerContainerStart interface {
	RunDockerContainerStart(attach bool, detachKeys string, interactive bool, container string, containers ...string) error
}

type dockerContainerStartCommand struct {
	command
	attach      *bool
	detachKeys  *string
	interactive *bool
	start       DockerContainerStart
}

func newDockerContainerStartCommand(w io.Writer, start DockerContainerStart) dockerContainerStartCommand {
	command := newCommand("start", "Start one or more stopped containers", w)
	c := dockerContainerStartCommand{
		command:     command,
		attach:      command.flags.Bool("attach", false, "Attach STDOUT/STDERR and forward signals"),
		detachKeys:  command.flags.String("detach-keys", "", "Override the key sequence for detaching a conatiner"),
		interactive: command.flags.Bool("interactive", false, "Attach container's STDIN"),
		start:       start,
	}
	c.flags.Usage = c.bufferHelp

	return c
}

func (c *dockerContainerStartCommand) usage() string {
	usage := []string{"Usage:", "docker", "container", "start"}
	c.flags.VisitAll(appendFlagUsage(usage))
	usage = append(usage, "<container>")
	usage = append(usage, "[<containers>...]")
	return strings.Join(usage, " ")
}

func (c *dockerContainerStartCommand) bufferHelp() {
	fmt.Fprintf(c.helpBuffer, "%s\n\n", c.help)
	fmt.Fprintf(c.helpBuffer, "%s\n", c.usage())

	fmt.Fprintf(c.helpBuffer, "\nArguments:\n")
	fmt.Fprintln(c.helpBuffer, "  container: The container to start")
	fmt.Fprintf(c.helpBuffer, "\nFlags:\n")
	c.flags.PrintDefaults()
}

func (c *dockerContainerStartCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *dockerContainerStartCommand) run(args []string) error {
	switch err := c.flags.Parse(args); err {
	case nil:

		args = c.flags.Args()
		if len(args) < 1 {
			return fmt.Errorf("'docker container start': too few arguments; expect 1 or more, but got %d", len(args))
		}

		return c.start.RunDockerContainerStart(*c.attach, *c.detachKeys, *c.interactive, args[0], args[1:]...)
	case flag.ErrHelp:
		return c.writeHelp()
	default:
		return err
	}
}

type dockerNetworkCommand struct {
	command
	inspect dockerNetworkInspectCommand
}

func newDockerNetworkCommand(w io.Writer, app Application) dockerNetworkCommand {
	command := newCommand("network", "Manage networks", w)
	c := dockerNetworkCommand{
		command: command,
		inspect: newDockerNetworkInspectCommand(w, app),
	}
	c.flags.Usage = c.bufferHelp

	return c
}

func (c *dockerNetworkCommand) usage() string {
	usage := []string{"Usage:", "docker", "network"}
	usage = append(usage, "<command>")
	c.flags.VisitAll(appendFlagUsage(usage))

	return strings.Join(usage, " ")
}

func (c *dockerNetworkCommand) bufferHelp() {
	fmt.Fprintf(c.helpBuffer, "%s\n\n", c.help)
	fmt.Fprintf(c.helpBuffer, "%s\n", c.usage())
	fmt.Fprintln(c.helpBuffer, "\nCommands:")
	fmt.Fprintln(c.helpBuffer, "  inspect: Display detailed information on one or more networks")

}

func (c *dockerNetworkCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *dockerNetworkCommand) run(args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("sub-command required")
	}
	switch args[0] {
	case "inspect":
		return c.inspect.run(args[1:])
	default:
		err := c.flags.Parse(args)
		if err == flag.ErrHelp {
			return c.writeHelp()
		}
		if err != nil {
			return err
		}
		return fmt.Errorf("Unknown command: %q", args[0])
	}
}

type DockerNetworkInspect interface {
	RunDockerNetworkInspect(format string, verbose bool, network string, networks ...string) error
}

type dockerNetworkInspectCommand struct {
	command
	format  *string
	verbose *bool
	inspect DockerNetworkInspect
}

func newDockerNetworkInspectCommand(w io.Writer, inspect DockerNetworkInspect) dockerNetworkInspectCommand {
	command := newCommand("inspect", "Display detailed information on one or more networks", w)
	c := dockerNetworkInspectCommand{
		command: command,
		format:  command.flags.String("format", "", "Format the output using the given Go template"),
		verbose: command.flags.Bool("verbose", false, "Verbose output for diagnostics"),
		inspect: inspect,
	}
	c.flags.Usage = c.bufferHelp

	return c
}

func (c *dockerNetworkInspectCommand) usage() string {
	usage := []string{"Usage:", "docker", "network", "inspect"}
	c.flags.VisitAll(appendFlagUsage(usage))
	usage = append(usage, "<network>")
	usage = append(usage, "[<networks>...]")
	return strings.Join(usage, " ")
}

func (c *dockerNetworkInspectCommand) bufferHelp() {
	fmt.Fprintf(c.helpBuffer, "%s\n\n", c.help)
	fmt.Fprintf(c.helpBuffer, "%s\n", c.usage())

	fmt.Fprintf(c.helpBuffer, "\nArguments:\n")
	fmt.Fprintln(c.helpBuffer, "  network: The network to inspect")
	fmt.Fprintf(c.helpBuffer, "\nFlags:\n")
	c.flags.PrintDefaults()
}

func (c *dockerNetworkInspectCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *dockerNetworkInspectCommand) run(args []string) error {
	switch err := c.flags.Parse(args); err {
	case nil:

		args = c.flags.Args()
		if len(args) < 1 {
			return fmt.Errorf("'docker network inspect': too few arguments; expect 1 or more, but got %d", len(args))
		}

		return c.inspect.RunDockerNetworkInspect(*c.format, *c.verbose, args[0], args[1:]...)
	case flag.ErrHelp:
		return c.writeHelp()
	default:
		return err
	}
}

type dockerVolumeCommand struct {
	command
	ls dockerVolumeLsCommand
	rm dockerVolumeRmCommand
}

func newDockerVolumeCommand(w io.Writer, app Application) dockerVolumeCommand {
	command := newCommand("volume", "Manage volumes", w)
	c := dockerVolumeCommand{
		command: command,
		ls:      newDockerVolumeLsCommand(w, app),
		rm:      newDockerVolumeRmCommand(w, app),
	}
	c.flags.Usage = c.bufferHelp

	return c
}

func (c *dockerVolumeCommand) usage() string {
	usage := []string{"Usage:", "docker", "volume"}
	usage = append(usage, "<command>")
	c.flags.VisitAll(appendFlagUsage(usage))

	return strings.Join(usage, " ")
}

func (c *dockerVolumeCommand) bufferHelp() {
	fmt.Fprintf(c.helpBuffer, "%s\n\n", c.help)
	fmt.Fprintf(c.helpBuffer, "%s\n", c.usage())
	fmt.Fprintln(c.helpBuffer, "\nCommands:")
	fmt.Fprintln(c.helpBuffer, "  ls: List volumes")
	fmt.Fprintln(c.helpBuffer, "  rm: Remove one or more volumes. You cannot remove a volume that is in user by a container.")

}

func (c *dockerVolumeCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *dockerVolumeCommand) run(args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("sub-command required")
	}
	switch args[0] {
	case "ls":
		return c.ls.run(args[1:])
	case "rm":
		return c.rm.run(args[1:])
	default:
		err := c.flags.Parse(args)
		if err == flag.ErrHelp {
			return c.writeHelp()
		}
		if err != nil {
			return err
		}
		return fmt.Errorf("Unknown command: %q", args[0])
	}
}

type DockerVolumeLs interface {
	RunDockerVolumeLs(filter string, format string, quiet bool) error
}

type dockerVolumeLsCommand struct {
	command
	filter *string
	format *string
	quiet  *bool
	ls     DockerVolumeLs
}

func newDockerVolumeLsCommand(w io.Writer, ls DockerVolumeLs) dockerVolumeLsCommand {
	command := newCommand("ls", "List volumes", w)
	c := dockerVolumeLsCommand{
		command: command,
		filter:  command.flags.String("filter", "", "Provide filter valies (e.g. 'dangling=true')"),
		format:  command.flags.String("format", "", "Pretty-print volumes using a Go template"),
		quiet:   command.flags.Bool("quiet", false, "Only display volume names"),
		ls:      ls,
	}
	c.flags.Usage = c.bufferHelp

	return c
}

func (c *dockerVolumeLsCommand) usage() string {
	usage := []string{"Usage:", "docker", "volume", "ls"}
	c.flags.VisitAll(appendFlagUsage(usage))

	return strings.Join(usage, " ")
}

func (c *dockerVolumeLsCommand) bufferHelp() {
	fmt.Fprintf(c.helpBuffer, "%s\n\n", c.help)
	fmt.Fprintf(c.helpBuffer, "%s\n", c.usage())

	fmt.Fprintf(c.helpBuffer, "\nFlags:\n")
	c.flags.PrintDefaults()
}

func (c *dockerVolumeLsCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *dockerVolumeLsCommand) run(args []string) error {
	switch err := c.flags.Parse(args); err {
	case nil:

		args = c.flags.Args()
		if len(args) < 0 {
			return fmt.Errorf("'docker volume ls': too few arguments; expect 0, but got %d", len(args))
		}
		if len(args) > 0 {
			return fmt.Errorf("'docker volume ls': too many arguments; expect 0, but got %d", len(args))
		}
		return c.ls.RunDockerVolumeLs(*c.filter, *c.format, *c.quiet)
	case flag.ErrHelp:
		return c.writeHelp()
	default:
		return err
	}
}

type DockerVolumeRm interface {
	RunDockerVolumeRm(force bool, volume string, volumes ...string) error
}

type dockerVolumeRmCommand struct {
	command
	force *bool
	rm    DockerVolumeRm
}

func newDockerVolumeRmCommand(w io.Writer, rm DockerVolumeRm) dockerVolumeRmCommand {
	command := newCommand("rm", "Remove one or more volumes. You cannot remove a volume that is in user by a container.", w)
	c := dockerVolumeRmCommand{
		command: command,
		force:   command.flags.Bool("force", false, "Force the removal of one or more volumes"),
		rm:      rm,
	}
	c.flags.Usage = c.bufferHelp

	return c
}

func (c *dockerVolumeRmCommand) usage() string {
	usage := []string{"Usage:", "docker", "volume", "rm"}
	c.flags.VisitAll(appendFlagUsage(usage))
	usage = append(usage, "<volume>")
	usage = append(usage, "[<volumes>...]")
	return strings.Join(usage, " ")
}

func (c *dockerVolumeRmCommand) bufferHelp() {
	fmt.Fprintf(c.helpBuffer, "%s\n\n", c.help)
	fmt.Fprintf(c.helpBuffer, "%s\n", c.usage())

	fmt.Fprintf(c.helpBuffer, "\nArguments:\n")
	fmt.Fprintln(c.helpBuffer, "  volume: The volume to remove")
	fmt.Fprintf(c.helpBuffer, "\nFlags:\n")
	c.flags.PrintDefaults()
}

func (c *dockerVolumeRmCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *dockerVolumeRmCommand) run(args []string) error {
	switch err := c.flags.Parse(args); err {
	case nil:

		args = c.flags.Args()
		if len(args) < 1 {
			return fmt.Errorf("'docker volume rm': too few arguments; expect 1 or more, but got %d", len(args))
		}

		return c.rm.RunDockerVolumeRm(*c.force, args[0], args[1:]...)
	case flag.ErrHelp:
		return c.writeHelp()
	default:
		return err
	}
}

type CLI struct {
	dockerCommand dockerCommand
}

func NewCLI(app Application) *CLI {
	return NewCLIWithWriter(os.Stdout, app)
}

func NewCLIWithWriter(w io.Writer, app Application) *CLI {
	return &CLI{
		dockerCommand: newDockerCommand(w, app),
	}
}

func (c *CLI) Run() error {
	return c.dockerCommand.run(os.Args[1:])
}
