// AUTOGENERATED -- DO NOT EDIT
package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"strings"
	"time"
)

type Application interface {
	Bar
	Foo
}

type command struct {
	w     io.Writer
	help  string
	flags *flag.FlagSet
}

func newCommand(w io.Writer, help string, flags *flag.FlagSet) command {
	return command{
		w:     w,
		help:  help,
		flags: flags,
	}
}

type rootCommand struct {
	command
	helpBuffer *bytes.Buffer
	bar        barCommand
	foo        fooCommand
}

func newRootCommand(w io.Writer, app Application) rootCommand {
	helpBuffer := new(bytes.Buffer)
	flags := flag.NewFlagSet("root", flag.ContinueOnError)
	flags.SetOutput(helpBuffer)

	c := rootCommand{
		command:    newCommand(w, "This is my application to do stuff", flags),
		helpBuffer: helpBuffer,
		bar:        newBarCommand(w, app),
		foo:        newFooCommand(w, app),
	}
	flags.Usage = c.bufferHelp

	return c
}

func (c *rootCommand) usage() string {
	usage := []string{
		"Usage:",
		os.Args[0],
	}
	subCommands := []string{
		"bar",
		"foo",
	}
	usage = append(usage, fmt.Sprintf("{%s}", strings.Join(subCommands, " | ")))
	c.flags.VisitAll(func(f *flag.Flag) {
		flagArg := ""
		if typ, _ := flag.UnquoteUsage(f); typ != "" {
			flagArg = fmt.Sprintf(" <%s>", typ)
		}
		usage = append(usage, fmt.Sprintf("[-%s%s]", f.Name, flagArg))
	})

	return strings.Join(usage, " ")
}

func (c *rootCommand) bufferHelp() {
	fmt.Fprintln(c.helpBuffer, c.help)
	fmt.Fprintln(c.helpBuffer, c.usage())
	fmt.Fprintln(c.helpBuffer, "Sub-Commands:")
	fmt.Fprintln(c.helpBuffer, "  bar: Do lots of bar")
	fmt.Fprintln(c.helpBuffer, "  foo: Do a foo")

}

func (c *rootCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *rootCommand) run(args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("sub-command required")
	}
	switch args[0] {
	case "bar":
		return c.bar.run(args[1:])
	case "foo":
		return c.foo.run(args[1:])
	default:
		err := c.flags.Parse(args)
		if err == flag.ErrHelp {
			return c.writeHelp()
		}
		if err != nil {
			return err
		}
		return fmt.Errorf("Unknown command: %q", args[0])
	}
}

type Bar interface {
	RunBar(vargs ...string) error
}

type barCommand struct {
	command
	helpBuffer *bytes.Buffer
	bar        Bar
}

func newBarCommand(w io.Writer, bar Bar) barCommand {
	helpBuffer := new(bytes.Buffer)
	flags := flag.NewFlagSet("bar", flag.ContinueOnError)
	flags.SetOutput(helpBuffer)

	c := barCommand{
		command:    newCommand(w, "Do lots of bar", flags),
		helpBuffer: helpBuffer,
		bar:        bar,
	}
	flags.Usage = c.bufferHelp

	return c
}

func (c *barCommand) usage() string {
	usage := []string{
		"Usage:",
		"bar",
	}

	c.flags.VisitAll(func(f *flag.Flag) {
		flagArg := ""
		if typ, _ := flag.UnquoteUsage(f); typ != "" {
			flagArg = fmt.Sprintf(" <%s>", typ)
		}
		usage = append(usage, fmt.Sprintf("[-%s%s]", f.Name, flagArg))
	})

	return strings.Join(usage, " ")
}

func (c *barCommand) bufferHelp() {
	fmt.Fprintln(c.helpBuffer, c.help)
	fmt.Fprintln(c.helpBuffer, c.usage())

}

func (c *barCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *barCommand) run(args []string) error {
	switch err := c.flags.Parse(args); err {
	case nil:

		args = c.flags.Args()
		return c.bar.RunBar(args...)
	case flag.ErrHelp:
		return c.writeHelp()
	default:
		return err
	}
}

type Foo interface {
	RunFoo(dryRun bool, wait time.Duration, in string, out string) error
}

type fooCommand struct {
	command
	helpBuffer *bytes.Buffer
	dryRun     *bool
	wait       *time.Duration
	foo        Foo
}

func newFooCommand(w io.Writer, foo Foo) fooCommand {
	helpBuffer := new(bytes.Buffer)
	flags := flag.NewFlagSet("foo", flag.ContinueOnError)
	flags.SetOutput(helpBuffer)

	c := fooCommand{
		command:    newCommand(w, "Do a foo", flags),
		helpBuffer: helpBuffer,
		dryRun:     flags.Bool("dry-run", false, "don't actually write to the output"),
		wait:       flags.Duration("wait", time.Duration(5000000000), "wait a bit before writing to the output"),
		foo:        foo,
	}
	flags.Usage = c.bufferHelp

	return c
}

func (c *fooCommand) usage() string {
	usage := []string{
		"Usage:",
		"foo",
	}

	c.flags.VisitAll(func(f *flag.Flag) {
		flagArg := ""
		if typ, _ := flag.UnquoteUsage(f); typ != "" {
			flagArg = fmt.Sprintf(" <%s>", typ)
		}
		usage = append(usage, fmt.Sprintf("[-%s%s]", f.Name, flagArg))
	})
	usage = append(usage, "<in>")
	usage = append(usage, "<out>")

	return strings.Join(usage, " ")
}

func (c *fooCommand) bufferHelp() {
	fmt.Fprintln(c.helpBuffer, c.help)
	fmt.Fprintln(c.helpBuffer, c.usage())

	fmt.Fprintln(c.helpBuffer, "Arguments:")
	fmt.Fprintln(c.helpBuffer, "  in: the input to foo")
	fmt.Fprintln(c.helpBuffer, "  out: the output of foo")
	fmt.Fprintln(c.helpBuffer, "Flags:")
	c.flags.PrintDefaults()
}

func (c *fooCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *fooCommand) run(args []string) error {
	switch err := c.flags.Parse(args); err {
	case nil:

		args = c.flags.Args()

		if len(args) < 2 {
			return fmt.Errorf("too few arguments to 'foo'; expected 2, but got %d", len(args))
		}
		if len(args) > 2 {
			return fmt.Errorf("too many arguments to 'foo'; expected 2, but got %d", len(args))
		}
		return c.foo.RunFoo(*c.dryRun, *c.wait, args[0], args[1])
	case flag.ErrHelp:
		return c.writeHelp()
	default:
		return err
	}
}

type CLI struct {
	rootCommand rootCommand
}

func NewCLI(app Application) *CLI {
	return NewCLIWithWriter(os.Stdout, app)
}

func NewCLIWithWriter(w io.Writer, app Application) *CLI {
	return &CLI{
		rootCommand: newRootCommand(w, app),
	}
}

func (c *CLI) Run() error {
	return c.rootCommand.run(os.Args[1:])
}
