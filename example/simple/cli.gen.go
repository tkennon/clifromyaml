// AUTOGENERATED -- DO NOT EDIT
package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"strings"
	"time"
)

// Application defines the entrypoints to the application logic.
type Application interface {
	Simple
}

type command struct {
	w          io.Writer
	help       string
	helpBuffer *bytes.Buffer
	flags      *flag.FlagSet
}

func newCommand(name string, help string, w io.Writer) command {
	flags := flag.NewFlagSet(name, flag.ContinueOnError)
	helpBuffer := new(bytes.Buffer)
	flags.SetOutput(helpBuffer)

	return command{
		w:          w,
		help:       help,
		helpBuffer: helpBuffer,
		flags:      flags,
	}
}

// appendFlagUsage returns a function that appends a string describing the flags
// usage to the slice passed in. The usage is of the form
// `[-<flag name> <flag type>]`. For boolean flags the <flag type> is omitted.
func appendFlagUsage(usage []string) func(f *flag.Flag) {
	return func(f *flag.Flag) {
		flagArg := ""
		if typ, _ := flag.UnquoteUsage(f); typ != "" {
			flagArg = fmt.Sprintf(" <%s>", typ)
		}
		usage = append(usage, fmt.Sprintf("[-%s%s]", f.Name, flagArg))
	}
}

type Simple interface {
	Run(wait time.Duration, first string, second string, somethings ...string) error
}

type simpleCommand struct {
	command
	wait   *time.Duration
	simple Simple
}

func newSimpleCommand(w io.Writer, simple Simple) simpleCommand {
	command := newCommand("simple", "A very simple application", w)
	c := simpleCommand{
		command: command,
		wait:    command.flags.Duration("wait", time.Duration(5000000000), "wait a bit before doing simple somethings"),
		simple:  simple,
	}
	c.flags.Usage = c.bufferHelp

	return c
}

func (c *simpleCommand) usage() string {
	usage := []string{"Usage:", "simple"}
	c.flags.VisitAll(appendFlagUsage(usage))
	usage = append(usage, "<first>")
	usage = append(usage, "<second>")
	usage = append(usage, "[<somethings>...]")
	return strings.Join(usage, " ")
}

func (c *simpleCommand) bufferHelp() {
	fmt.Fprintf(c.helpBuffer, "%s\n\n", c.help)
	fmt.Fprintf(c.helpBuffer, "%s\n", c.usage())

	fmt.Fprintf(c.helpBuffer, "\nArguments:\n")
	fmt.Fprintln(c.helpBuffer, "  first: The first something to do simply")
	fmt.Fprintln(c.helpBuffer, "  second: Another something")
	fmt.Fprintf(c.helpBuffer, "\nFlags:\n")
	c.flags.PrintDefaults()
}

func (c *simpleCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *simpleCommand) run(args []string) error {
	switch err := c.flags.Parse(args); err {
	case nil:

		args = c.flags.Args()
		if len(args) < 2 {
			return fmt.Errorf("'simple': too few arguments; expect 2 or more, but got %d", len(args))
		}

		return c.simple.Run(*c.wait, args[0], args[1], args[2:]...)
	case flag.ErrHelp:
		return c.writeHelp()
	default:
		return err
	}
}

type CLI struct {
	simpleCommand simpleCommand
}

func NewCLI(app Application) *CLI {
	return NewCLIWithWriter(os.Stdout, app)
}

func NewCLIWithWriter(w io.Writer, app Application) *CLI {
	return &CLI{
		simpleCommand: newSimpleCommand(w, app),
	}
}

func (c *CLI) Run() error {
	return c.simpleCommand.run(os.Args[1:])
}
