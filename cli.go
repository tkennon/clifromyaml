// AUTOGENERATED -- DO NOT EDIT
package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"strings"
)

type Application interface {
	Root
}

type command struct {
	w     io.Writer
	help  string
	flags *flag.FlagSet
}

func newCommand(w io.Writer, help string, flags *flag.FlagSet) command {
	return command{
		w:     w,
		help:  help,
		flags: flags,
	}
}

type Root interface {
	Run(dryRun bool, outfile string, packageName string, yamlSpec string) error
}

type rootCommand struct {
	command
	helpBuffer  *bytes.Buffer
	version     *bool
	dryRun      *bool
	outfile     *string
	packageName *string
	root        Root
}

func newRootCommand(w io.Writer, root Root) rootCommand {
	helpBuffer := new(bytes.Buffer)
	flags := flag.NewFlagSet("root", flag.ContinueOnError)
	flags.SetOutput(helpBuffer)

	c := rootCommand{
		command:     newCommand(w, "Generate Golang CLI bindings from a YAML definition", flags),
		helpBuffer:  helpBuffer,
		version:     flags.Bool("version", false, "print version"),
		dryRun:      flags.Bool("dry-run", false, "Don't write the generated Go bindings anywhere, just parse the yaml and print any errors."),
		outfile:     flags.String("outfile", "", "The `file` that the generated CLI bindings should be written to. If empty then they will be written to stdout."),
		packageName: flags.String("package-name", "main", "The package name to use for the generated Go bindings"),
		root:        root,
	}
	flags.Usage = c.bufferHelp

	return c
}

func (c *rootCommand) usage() string {
	usage := []string{
		"Usage:",
		os.Args[0],
	}

	c.flags.VisitAll(func(f *flag.Flag) {
		flagArg := ""
		if typ, _ := flag.UnquoteUsage(f); typ != "" {
			flagArg = fmt.Sprintf(" <%s>", typ)
		}
		usage = append(usage, fmt.Sprintf("[-%s%s]", f.Name, flagArg))
	})
	usage = append(usage, "<yaml-spec>")

	return strings.Join(usage, " ")
}

func (c *rootCommand) bufferHelp() {
	fmt.Fprintln(c.helpBuffer, c.help)
	fmt.Fprintln(c.helpBuffer, c.usage())

	fmt.Fprintln(c.helpBuffer, "Arguments:")
	fmt.Fprintln(c.helpBuffer, "  yaml-spec: the YAML file containing the CLI definition")
	fmt.Fprintln(c.helpBuffer, "Flags:")
	c.flags.PrintDefaults()
}

func (c *rootCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *rootCommand) writeVersion() error {
	_, err := fmt.Fprintln(c.w, "0.0.1")
	return err
}

func (c *rootCommand) run(args []string) error {
	switch err := c.flags.Parse(args); err {
	case nil:
		if *c.version {
			return c.writeVersion()
		}
		args = c.flags.Args()

		if len(args) < 1 {
			return fmt.Errorf("too few arguments to 'root'; expected 1, but got %d", len(args))
		}
		if len(args) > 1 {
			return fmt.Errorf("too many arguments to 'root'; expected 1, but got %d", len(args))
		}
		return c.root.Run(*c.dryRun, *c.outfile, *c.packageName, args[0])
	case flag.ErrHelp:
		return c.writeHelp()
	default:
		return err
	}
}

type CLI struct {
	rootCommand rootCommand
}

func NewCLI(app Application) *CLI {
	return NewCLIWithWriter(os.Stdout, app)
}

func NewCLIWithWriter(w io.Writer, app Application) *CLI {
	return &CLI{
		rootCommand: newRootCommand(w, app),
	}
}

func (c *CLI) Run() error {
	return c.rootCommand.run(os.Args[1:])
}
