// AUTOGENERATED -- DO NOT EDIT
package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"strings"
)

// Application defines the entrypoints to the application logic.
type Application interface {
	Clifromyaml
}

type command struct {
	w          io.Writer
	help       string
	helpBuffer *bytes.Buffer
	flags      *flag.FlagSet
}

func newCommand(name string, help string, w io.Writer) command {
	flags := flag.NewFlagSet(name, flag.ContinueOnError)
	helpBuffer := new(bytes.Buffer)
	flags.SetOutput(helpBuffer)

	return command{
		w:          w,
		help:       help,
		helpBuffer: helpBuffer,
		flags:      flags,
	}
}

// appendFlagUsage returns a function that appends a string describing the flags
// usage to the slice passed in. The usage is of the form
// `[--<flag name> <flag type>]`. For boolean flags the <flag type> is omitted.
func appendFlagUsage(usage *[]string) func(f *flag.Flag) {
	return func(f *flag.Flag) {
		flagArg := ""
		if typ, _ := flag.UnquoteUsage(f); typ != "" {
			flagArg = fmt.Sprintf(" <%s>", typ)
		}
		dash := "-"
		if len(f.Name) > 1 {
			dash = "--"
		}
		*usage = append(*usage, fmt.Sprintf("[%s%s%s]", dash, f.Name, flagArg))
	}
}

type Clifromyaml interface {
	Run(dryRun bool, outfile string, packageName string, stdout bool, yamlSpec string) error
}

type clifromyamlCommand struct {
	command
	version            *bool
	dryRun             *bool
	dryRunChoices      []bool
	outfile            *string
	outfileChoices     []string
	packageName        *string
	packageNameChoices []string
	stdout             *bool
	stdoutChoices      []bool
	clifromyaml        Clifromyaml
}

func newClifromyamlCommand(w io.Writer, clifromyaml Clifromyaml) clifromyamlCommand {
	command := newCommand("clifromyaml", "Generate Golang CLI bindings from a YAML definition.", w)
	c := clifromyamlCommand{
		command:            command,
		version:            command.flags.Bool("version", false, "print version"),
		dryRun:             command.flags.Bool("dry-run", false, "Don't write the generated Go bindings anywhere, just parse the yaml and print any errors."),
		dryRunChoices:      nil,
		outfile:            command.flags.String("outfile", "", "The `file` that the generated CLI bindings should be written to. If empty then they will be written to <yaml-spec>.go."),
		outfileChoices:     nil,
		packageName:        command.flags.String("package-name", "main", "The package name to use for the generated Go bindings."),
		packageNameChoices: nil,
		stdout:             command.flags.Bool("stdout", false, "Print the generated CLI bindings to stdout."),
		stdoutChoices:      nil,
		clifromyaml:        clifromyaml,
	}
	c.flags.Usage = c.bufferHelp

	return c
}

func (c *clifromyamlCommand) validateFlags() error {
	if err := func() error {
		if len(c.dryRunChoices) == 0 {
			return nil
		}
		for _, choice := range c.dryRunChoices {
			if choice == *c.dryRun {
				return nil
			}
		}
		return fmt.Errorf("'dry-run' must be one of %v", c.dryRunChoices)
	}(); err != nil {
		return err
	}
	if err := func() error {
		if len(c.outfileChoices) == 0 {
			return nil
		}
		for _, choice := range c.outfileChoices {
			if choice == *c.outfile {
				return nil
			}
		}
		return fmt.Errorf("'outfile' must be one of %v", c.outfileChoices)
	}(); err != nil {
		return err
	}
	if err := func() error {
		if len(c.packageNameChoices) == 0 {
			return nil
		}
		for _, choice := range c.packageNameChoices {
			if choice == *c.packageName {
				return nil
			}
		}
		return fmt.Errorf("'package-name' must be one of %v", c.packageNameChoices)
	}(); err != nil {
		return err
	}
	if err := func() error {
		if len(c.stdoutChoices) == 0 {
			return nil
		}
		for _, choice := range c.stdoutChoices {
			if choice == *c.stdout {
				return nil
			}
		}
		return fmt.Errorf("'stdout' must be one of %v", c.stdoutChoices)
	}(); err != nil {
		return err
	}
	return nil
}

func (c *clifromyamlCommand) validateArgs(args []string) error {
	if len(args) < 1 {
		return fmt.Errorf("'clifromyaml': too few arguments; expect 1, but got %d", len(args))
	}
	if len(args) > 1 {
		return fmt.Errorf("'clifromyaml': too many arguments; expect 1, but got %d", len(args))
	}
	return nil
}

func (c *clifromyamlCommand) usage() string {
	usage := []string{"Usage:", "clifromyaml"}
	c.flags.VisitAll(appendFlagUsage(&usage))
	usage = append(usage, "<yaml-spec>")

	return strings.Join(usage, " ")
}

func (c *clifromyamlCommand) bufferHelp() {
	fmt.Fprintf(c.helpBuffer, "%s\n\n", c.help)
	fmt.Fprintf(c.helpBuffer, "%s\n", c.usage())

	fmt.Fprintf(c.helpBuffer, "\nArguments:\n")
	fmt.Fprintln(c.helpBuffer, "  yaml-spec: the YAML file containing the CLI definition")
	fmt.Fprintf(c.helpBuffer, "\nFlags:\n")
	c.flags.PrintDefaults()
}

func (c *clifromyamlCommand) writeHelp() error {
	_, err := c.helpBuffer.WriteTo(c.w)
	return err
}

func (c *clifromyamlCommand) writeVersion() error {
	_, err := fmt.Fprintln(c.w, "0.0.5")
	return err
}

func (c *clifromyamlCommand) run(args []string) error {
	switch err := c.flags.Parse(args); err {
	case nil:
		if *c.version {
			return c.writeVersion()
		}
		// Check that all flags are oneof the defined choices.
		if err := c.validateFlags(); err != nil {
			return err
		}
		args = c.flags.Args()
		if err := c.validateArgs(args); err != nil {
			return err
		}
		return c.clifromyaml.Run(*c.dryRun, *c.outfile, *c.packageName, *c.stdout, args[0])
	case flag.ErrHelp:
		return c.writeHelp()
	default:
		return err
	}
}

// CLI is the Command Line Interface for clifromyaml.
type CLI struct {
	clifromyamlCommand clifromyamlCommand
}

// NewCLI returns a new CLI that parses all flags and arguments from the command
// line and invokes the corresponding Application method.
func NewCLI(app Application) *CLI {
	return NewCLIWithWriter(os.Stdout, app)
}

// NewCLIWithWriter is like NewCLI, but any output is written to w instead of
// stdout.
func NewCLIWithWriter(w io.Writer, app Application) *CLI {
	return &CLI{
		clifromyamlCommand: newClifromyamlCommand(w, app),
	}
}

// Run runs the CLI. It parses all flags and arguments and attempts to invoke to
// corresponding method of Application.
func (c *CLI) Run() error {
	return c.clifromyamlCommand.run(os.Args[1:])
}
