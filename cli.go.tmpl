{{define "command.tmpl"}}
{{if eq (len .SubCommands) 0}}type {{title (toCamelCase .Name)}} interface {
    Run{{if not .IsRoot}}{{title (toCamelCase .Name)}}{{end}}({{.ParametersAndTypes}}) error
}
{{end}}
type {{toCamelCase .Name}}Command struct {
    command
    helpBuffer *bytes.Buffer{{if ne .Version ""}}
    version *bool{{end}}
    {{range $fname, $flag := .Flags}}{{toCamelCase $fname}} *{{$flag.Type}}
    {{end}}{{range $cname, $command := .SubCommands}}{{toCamelCase $cname}} {{toCamelCase $cname}}Command
    {{else}}{{toCamelCase .Name}} {{title (toCamelCase .Name)}}{{end}}
}

func new{{title (toCamelCase .Name)}}Command(w io.Writer, {{if eq (len .SubCommands) 0}}{{toCamelCase .Name}} {{title (toCamelCase .Name)}}{{else}}app Application{{end}}) {{toCamelCase .Name}}Command {
    helpBuffer := new(bytes.Buffer)
    flags := flag.NewFlagSet("{{.Name}}", flag.ContinueOnError)
    flags.SetOutput(helpBuffer)

    c := {{toCamelCase .Name}}Command{
        command: newCommand(w, "{{.Help}}", flags),
        helpBuffer: helpBuffer,{{if ne .Version ""}}
        version: flags.Bool("version", false, "print version"),{{end}}
        {{range $fname, $flag := .Flags}}{{toCamelCase $fname}}: flags.{{$flag.FlagFunc}}("{{$fname}}", {{$flag.DefaultArg}}, "{{$flag.Help}}"),
        {{end}}{{range $cname, $command := .SubCommands}}{{toCamelCase $cname}}: new{{title (toCamelCase $cname)}}Command(w, app),
        {{else}}{{toCamelCase .Name}}: {{toCamelCase .Name}},{{end}}
    }
    flags.Usage = c.bufferHelp

    return c
}

func (c *{{toCamelCase .Name}}Command) usage() string {
    usage := []string{
        "Usage:",
        {{if .IsRoot}}os.Args[0]{{else}}"{{.Name}}"{{end}},
    }
    {{if gt (len .SubCommands) 0}}subCommands := []string{
        {{range $cname, $command := .SubCommands}}"{{$cname}}",
        {{end}}
    }
    usage = append(usage, fmt.Sprintf("{%s}", strings.Join(subCommands, " | "))){{end}}
    c.flags.VisitAll(func(f *flag.Flag) {
        flagArg := ""
        if typ, _ := flag.UnquoteUsage(f); typ != "" {
            flagArg = fmt.Sprintf(" <%s>", typ)
        }
        usage = append(usage, fmt.Sprintf("[-%s%s]", f.Name, flagArg))
    })
    {{range .Args}}{{range $aname, $arg := .}}usage = append(usage, "<{{$aname}}>"){{end}}
    {{end}}
    return strings.Join(usage, " ")
}

func (c *{{toCamelCase .Name}}Command) bufferHelp() {
    fmt.Fprintln(c.helpBuffer, c.help)
    fmt.Fprintln(c.helpBuffer, c.usage())
    {{if gt (len .SubCommands) 0}}fmt.Fprintln(c.helpBuffer, "Sub-Commands:"){{end}}
    {{range $cname, $command := .SubCommands}}fmt.Fprintln(c.helpBuffer, "  {{$cname}}: {{$command.Help}}")
    {{end}}
    {{if gt (len .Args) 0}}fmt.Fprintln(c.helpBuffer, "Arguments:"){{end}}
    {{range .Args}}{{range $argName, $help := .}}fmt.Fprintln(c.helpBuffer, "  {{$argName}}: {{$help}}"){{end}}
    {{end}}{{if gt (len .Flags) 0}}fmt.Fprintln(c.helpBuffer, "Flags:")
	c.flags.PrintDefaults(){{end}}
}

func (c *{{toCamelCase .Name}}Command) writeHelp() error {
    _, err := c.helpBuffer.WriteTo(c.w)
    return err
}

{{if ne .Version ""}}
func (c *{{toCamelCase .Name}}Command) writeVersion() error {
    _, err := fmt.Fprintln(c.w, "{{.Version}}")
    return err
}
{{end}}

func (c *{{toCamelCase .Name}}Command) run(args []string) error {
    {{if gt (len .SubCommands) 0}}if len(args) == 0 {
        return fmt.Errorf("sub-command required")
    }
    switch args[0] { {{range $cname, $command := .SubCommands}}
    case "{{$cname}}":
        return c.{{toCamelCase $cname}}.run(args[1:]){{end}}
    default:
        err := c.flags.Parse(args)
        if err == flag.ErrHelp {
            return c.writeHelp()
        }
        if err != nil {
            return err
        }{{if ne .Version ""}}
        if *c.version {
            return c.writeVersion()
        }{{end}}
        return fmt.Errorf("Unknown command: %q", args[0])
    }{{else}}switch err := c.flags.Parse(args); err {
    case nil:
        {{if ne .Version ""}}if *c.version {
            return c.writeVersion()
        }{{end}}
        args = c.flags.Args()
        {{if eq .VariadicArgs true}}return c.{{toCamelCase .Name}}.Run{{title (toCamelCase .Name)}}({{.Parameters}}){{else}}
        if len(args) < {{len .Args}} {
            return fmt.Errorf("too few arguments to '{{.Name}}'; expected {{len .Args}}, but got %d", len(args))
        }
        if len(args) > {{len .Args}} {
            return fmt.Errorf("too many arguments to '{{.Name}}'; expected {{len .Args}}, but got %d", len(args))
        }
        return c.{{toCamelCase .Name}}.Run{{if not .IsRoot}}{{title (toCamelCase .Name)}}{{end}}({{.Parameters}}){{end}}
    case flag.ErrHelp:
        return c.writeHelp()
    default:
        return err
    }{{end}}
}

{{range $cname, $command := .SubCommands}}
{{template "command.tmpl" ($command.WithName $cname)}}
{{end}}
{{end}}
// AUTOGENERATED -- DO NOT EDIT
package {{.PackageName}}

import (
    "bytes"
    "flag"
    "fmt"
    "io"
    "os"
    "strings"
    {{if .StdlibPackageIsUsed "time"}}"time"{{end}}
)

type Application interface { {{range $cname, $command := .Command.SubCommands}}
    {{title (toCamelCase $cname)}}{{else}}
    Root{{end}}
}

type command struct {
    w io.Writer
    help string
    flags *flag.FlagSet
}

func newCommand(w io.Writer, help string, flags *flag.FlagSet) command {
    return command{
        w: w,
        help: help,
        flags: flags,
    }
}

{{template "command.tmpl" (.Command.WithName "root")}}

type CLI struct {
    rootCommand rootCommand
}

func NewCLI(app Application) *CLI {
    return NewCLIWithWriter(os.Stdout, app)
}

func NewCLIWithWriter(w io.Writer, app Application) *CLI {
    return &CLI{
        rootCommand: newRootCommand(w, app),
    }
}

func (c *CLI) Run() error {
    return c.rootCommand.run(os.Args[1:])
}
